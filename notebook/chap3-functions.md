## 3. 함수를 잘 만드는 법



## 3.1 작게, 더 작게
- 가로 150자, 100줄을 넘어서는 안된다. 아니, 20줄도 길다.
- 블록과 들여쓰기 : if/else/while문 안에 들어가는 블록은 한 줄이어야 한다.
    - 거기 안에서 함수를 호출한다.
    - 중첩 구조가 생길만큼 함수가 커져서는 안된다.
    - 함수의 들여쓰기 수준은 **1단이나 2단**을 넘어가면 안 된다.
    
    
## 3.2 한 가지만 해라!
- 함수는 한가지를 해야한다. 그 한가지를 잘해야한다. 그 한가지만을 해야한다.
- 우리가 함수를 만드는 이유 : 큰 개념을 다음 추상화 수준에서 여러 단계로 나눠 수행하기 위해서
- 함수가 '한 가지'만 하는지 판단하는 방법
    - 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는거다.
    - 자연스럽게 섹션으로 나누기 어렵다.

## 3.3 함수 당 추상화 수준은 하나로!
- 함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 **추상화 수준**이 동일해야 한다.
- 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다. 특정 표현이 근본 개념인지 세부사항인지 구분하기 어렵기 때문.
- 내려가기 규칙 : 위에서 아래로 코드 읽기
    - 코드는 위애서 아래로 이야기처럼 읽혀야 한다.
    - 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.
    
## 3.4 Switch 문 
- Switch문은 본질적으로 N가지를 처리한다.
- 예시 Switch문이 가지는 문제들
    - 1) 함수가 길어진다.
    - 2) '한 가지' 작업만 수행하지 않는다. 
    - 3) SRP(single responsibility principle, 객체 지향 프로그래밍에서 단일 책임 원칙이란 모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 함을 일컫는다.)를 위반한다.
    - 4) OCP(개방-폐쇄 원칙, Open-Closed Principle, 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다'는 프로그래밍 원칙이다.)를 위반한다. 
    
- switch문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법은 있다. 다형성을 이용한다.

## 3.5 서술적인 이름을 사용해라!

